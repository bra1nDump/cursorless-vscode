import {
  createPatternMatchers,
  argumentMatcher,
  leadingMatcher,
  trailingMatcher,
} from "../util/nodeMatchers";
import { NodeMatcherAlternative } from "../typings/Types";
import { SimpleScopeTypeType } from "../typings/targetDescriptor.types";

// Generated by the following command:
// >  curl https://raw.githubusercontent.com/jiyee/tree-sitter-objc/01dbc2cc0289f29146cab8194b51f732d7489a34/src/node-types.json | jq '[.[] | select(.type == "compound_statement") | .children.types[].type] + [.[] | select(.type == "_statement") | .subtypes[].type]'
const STATEMENT_TYPES = [
    "BOOL",
    "Class",
    "IMP",
    "SEL",
    "_statement",
    "atomic_specifier",
    "auto",
    "category_implementation",
    "category_interface",
    "class_forward_declaration",
    "class_implementation",
    "class_interface",
    "compatibility_alias_declaration",
    "declaration",
    "enum_specifier",
    "function_definition",
    "generic_type_specifier",
    "id",
    "instancetype",
    "linkage_specification",
    "macro_type_specifier",
    "module_import",
    "ns_enum_specifier",
    "preproc_def",
    "preproc_function_def",
    "preproc_if",
    "preproc_ifdef",
    "preproc_import",
    "preproc_include",
    "primitive_type",
    "protocol_declaration",
    "protocol_forward_declaration",
    "sized_type_specifier",
    "struct_specifier",
    "type_definition",
    "type_identifier",
    "typeof_specifier",
    "union_specifier",
    "autoreleasepool_statement",
    "break_statement",
    "case_statement",
    "compound_statement",
    "continue_statement",
    "do_statement",
    "expression_statement",
    "for_in_statement",
    "for_statement",
    "goto_statement",
    "if_statement",
    "labeled_statement",
    "return_statement",
    "switch_statement",
    "synchronized_statement",
    "throw_statement",
    "try_catch_statement",
    "while_statement"
];

// Manually constructed
const TYPE_TYPES = [
  "class_specifier",
  "enum_specifier",
  "primitive_type",
  "scoped_type_identifier",
  "sized_type_specifier",
  "struct_specifier",
  "type_identifier",
];

const nodeMatchers: Partial<
  Record<SimpleScopeTypeType, NodeMatcherAlternative>
> = {
  statement: STATEMENT_TYPES,
  class: [
    "class_interface",
    "class_implementation",
    "category_interface",
    "class_forward_declaration",
    "protocol_declaration"
  ],
  className: [
    "class_interface[name]",
    "class_implementation[name]",
    "category_interface[name]",
  ],
  ifStatement: "if_statement",
  string: "string_expression",
  comment: "comment",
  anonymousFunction: "block_expression",
  list: "array_expression",
  functionCall: ["call_expression", "message_expressions"],
//   functionCallee: [
//     "call_expression[function]",
//     "declaration.init_declarator[declarator]!",
//   ],s
  name: [
    "*[declarator][declarator][name]",
    "*[declarator][name]",
    "*[declarator][declarator]",
    "*[declarator]",
    "assignment_expression[left]",
    "*[name]",
  ],
  namedFunction: ["method_declaration", "method_definition"],
  type: trailingMatcher(TYPE_TYPES.concat(["*[type]"])),
  functionName: [
    // - (void)full:(BOOL)foulParameter another:(BOOL)another;
    // extracted: foulParameter
    "method_declaration[selector][0][keyword]",
    "method_definition[selector][0][keyword]",
    "declaration.function_declarator![declarator]", // void funcName();
  ],
  value: leadingMatcher(
    [
      "*[declarator][value]",
      "*[value]",
      "assignment_expression[right]",
      "optional_parameter_declaration[default_value]",
    ],
    [":", "=", "+=", "-=", "*=", "/=", "%=", "&=", "|=", "^=", "<<=", ">>="]
  ),
  collectionItem: argumentMatcher("array_expression", "dictionary_expression"),
  argumentOrParameter: argumentMatcher("parameter_list","keyword_argument_list", "keyword_argument_list"),
  attribute: "attribute",
};

export default createPatternMatchers(nodeMatchers);
